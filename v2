import streamlit as st
import pandas as pd
import plotly.graph_objects as go
from datetime import datetime
from io import BytesIO

# =============================================================================
# Page Configuration
# =============================================================================
st.set_page_config(
    page_title="æº«å®¤æ°£é«”ç›¤æŸ¥å„€è¡¨æ¿",
    page_icon="ğŸŒ",
    layout="wide"
)

# =============================================================================
# User Authentication
# =============================================================================
# In a real app, use a database and hashed passwords!
USERS = {
    "Elvis": "0000",
    "Nutc1": "0001",
    "Nutc2": "0002",
    "Nutc3": "0003"
}


def login_page():
    """Renders the login page."""
    st.title("æº«å®¤æ°£é«”ç›¤æŸ¥ç³»çµ±ç™»å…¥")
    st.write("è«‹ä½¿ç”¨æ‚¨çš„å¸³è™Ÿå¯†ç¢¼ç™»å…¥")

    with st.form("login_form"):
        username = st.text_input("å¸³è™Ÿ (Username)")
        password = st.text_input("å¯†ç¢¼ (Password)", type="password")
        submitted = st.form_submit_button("ç™»å…¥")

        if submitted:
            if username in USERS and USERS[username] == password:
                st.session_state.logged_in = True
                st.session_state.username = username
                st.success("ç™»å…¥æˆåŠŸï¼")
                st.rerun()
            else:
                st.error("å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤")


# =============================================================================
# Helper Functions & Data Initialization
# =============================================================================
def initialize_state():
    """
    Initializes session state with default values.
    This function is now more robust, checking for each key individually.
    """
    # --- State flags ---
    if "show_dashboard" not in st.session_state:
        st.session_state.show_dashboard = False

    # --- Inventory Year ---
    if "inventory_year" not in st.session_state:
        years = range(datetime.now().year + 25, 2019, -1)
        st.session_state.inventory_year = datetime.now().year if datetime.now().year in years else years[0]

    # --- Data Dictionaries ---
    if "s1_data" not in st.session_state:
        st.session_state.s1_data = {
            'ç‡ƒæ–™æ²¹': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002567},
            'å¤©ç„¶æ°£(NG)': {'usage': 100, 'unit': 'åº¦/å¹´', 'factor': 0.001881},
            'æ¶²åŒ–çŸ³æ²¹æ°£(LPG)': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.001754},
            'æ±½æ²¹': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002271},
            'æŸ´æ²¹': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002615},
            'æ½¤æ»‘æ²¹': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002956},
        }
    if "s2_data" not in st.session_state:
        st.session_state.s2_data = {
            'è»Šç”¨æ±½æ²¹': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002298},
            'è»Šç”¨æŸ´æ²¹': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002722},
            'ç…¤æ²¹': {'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002567},
            'æ½¤æ»‘æ²¹_mobile': {'name': 'æ½¤æ»‘æ²¹', 'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.002956},
            'æ¶²åŒ–çŸ³æ²¹æ°£(LPG)_mobile': {'name': 'æ¶²åŒ–çŸ³æ²¹æ°£(LPG)', 'usage': 100, 'unit': 'å…¬å‡/å¹´', 'factor': 0.001803},
            'æ¶²åŒ–å¤©ç„¶æ°£(LNG)': {'usage': 100, 'unit': 'åº¦/å¹´', 'factor': 0.002241},
        }
    if "s3_septic_system" not in st.session_state:
        st.session_state.s3_septic_system = 'å¦ (ä½¿ç”¨åŒ–ç³æ± )'
    if "s3_data" not in st.session_state:
        st.session_state.s3_data = {
            'å¹³æ—¥æ—¥é–“ä½¿ç”¨å­¸ç”Ÿ': {'usage': 100, 'factor': 0.0021},
            'å¹³æ—¥å¤œé–“ä½¿ç”¨å­¸ç”Ÿ': {'usage': 10, 'factor': 0.0005},
            'å‡æ—¥ä½¿ç”¨å­¸ç”Ÿ': {'usage': 0, 'factor': 0.0},
            'ä½å®¿äººå“¡': {'usage': 0, 'factor': 0.0},
            'å¹³æ—¥æ—¥é–“ä½¿ç”¨å“¡å·¥': {'usage': 50, 'factor': 0.0021},
            'å¹³æ—¥å¤œé–“ä½¿ç”¨å“¡å·¥': {'usage': 5, 'factor': 0.0005},
            'å‡æ—¥ä½¿ç”¨å“¡å·¥': {'usage': 0, 'factor': 0.0},
        }
    if "s4_data" not in st.session_state:
        st.session_state.s4_data = {
            'äºŒæ°§åŒ–ç¢³æ»…ç«å™¨': {'usage': 1, 'gwp': 1, 'factor': None},
            'FM-200': {'usage': 1, 'gwp': 3350, 'factor': None},
            'BCå‹ä¹¾ç²‰æ»…ç«å™¨': {'usage': 1, 'gwp': None, 'factor': 0.0003},
            'KBCå‹ä¹¾ç²‰æ»…ç«å™¨': {'usage': 1, 'gwp': None, 'factor': 0.0002},
        }
    if "s5_data" not in st.session_state:
        st.session_state.s5_data = {
            'HFC-23/R-23': {'usage': 0.5, 'gwp': 12400}, 'HFC-32/R-32': {'usage': 0.1, 'gwp': 677},
            'HFC-41': {'usage': 0.0, 'gwp': 116}, 'HFC-134': {'usage': 0.0, 'gwp': 1120},
            'HFC-134a/R-134a': {'usage': 0.0, 'gwp': 1300}, 'HFC-143': {'usage': 0.0, 'gwp': 328},
            'HFC-143a/R-143a': {'usage': 0.0, 'gwp': 4800}, 'HFC-152': {'usage': 0.0, 'gwp': 16},
            'HFC-152a/R-152a': {'usage': 0.0, 'gwp': 138}, 'R401a': {'usage': 0.0, 'gwp': 1130},
            'R401B': {'usage': 0.0, 'gwp': 1236}, 'R404A': {'usage': 0.5, 'gwp': 3943},
            'R407A': {'usage': 0.0, 'gwp': 1923}, 'R407B': {'usage': 0.0, 'gwp': 2547},
            'R407C': {'usage': 0.0, 'gwp': 1624}, 'R408A': {'usage': 0.0, 'gwp': 3257},
            'R410A': {'usage': 0.0, 'gwp': 1924}, 'R413A': {'usage': 0.0, 'gwp': 1945},
            'R417A': {'usage': 0.0, 'gwp': 2127}, 'R507A': {'usage': 0.0, 'gwp': 3985}
        }
    if "s6_data" not in st.session_state:
        st.session_state.s6_data = {
            'æ±½è»Š-æ±½æ²¹': {'distance': 100, 'factor': 0.104}, 'æ±½è»Š-é›»å‹•è»Š': {'distance': 100, 'factor': 0.04},
            'æ©Ÿè»Š-ä¸€èˆ¬æ©Ÿè»Š': {'distance': 100, 'factor': 0.079}, 'æ©Ÿè»Š-é›»å‹•æ©Ÿè»Š': {'distance': 100, 'factor': 0.017},
            'å…¬è»Š/å®¢é‹': {'distance': 100, 'factor': 0.078}, 'æ·é‹': {'distance': 100, 'factor': 0.04},
            'ç«è»Š': {'distance': 0, 'factor': 0.04}, 'é«˜éµ': {'distance': 0, 'factor': 0.028}
        }
    if "s7_electricity" not in st.session_state:
        months = ["ä¸€æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ", "äº”æœˆ", "å…­æœˆ", "ä¸ƒæœˆ", "å…«æœˆ", "ä¹æœˆ", "åæœˆ", "åä¸€æœˆ", "åäºŒæœˆ"]
        st.session_state.s7_electricity = {m: 10000 for m in months}
    if "s7_water" not in st.session_state:
        months = ["ä¸€æœˆ", "äºŒæœˆ", "ä¸‰æœˆ", "å››æœˆ", "äº”æœˆ", "å…­æœˆ", "ä¸ƒæœˆ", "å…«æœˆ", "ä¹æœˆ", "åæœˆ", "åä¸€æœˆ", "åäºŒæœˆ"]
        st.session_state.s7_water = {m: 100 for m in months}
    if "s7_water_source" not in st.session_state:
        st.session_state.s7_water_source = 'å°ç£è‡ªä¾†æ°´ç‡Ÿæ¥­äº‹æ¥­è™•'
    if "water_factors" not in st.session_state:
        st.session_state.water_factors = {'å°ç£è‡ªä¾†æ°´ç‡Ÿæ¥­äº‹æ¥­è™•': 0.1872, 'è‡ºåŒ—è‡ªä¾†æ°´ç‡Ÿæ¥­äº‹æ¥­è™•': 0.0666}


# =============================================================================
# Excel Export Function
# =============================================================================
def to_excel():
    """
    Serializes all input data from session state into a multi-sheet Excel file.
    Returns the file as a bytes object for download.
    """
    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        # Sheet 1: å›ºå®šæº
        df1 = pd.DataFrame.from_dict(st.session_state.s1_data, orient='index')
        df1['æ’æ”¾é‡(tCO2e)'] = df1['usage'] * df1['factor']
        df1.index.name = 'ç‡ƒæ–™é¡åˆ¥'
        df1.reset_index(inplace=True)
        df1.rename(columns={'usage': 'ä½¿ç”¨é‡', 'unit': 'å–®ä½', 'factor': 'æ’æ”¾ä¿‚æ•¸'}, inplace=True)
        df1.to_excel(writer, sheet_name='å›ºå®šæº', index=False)

        # Sheet 2: ç§»å‹•æº
        df2_data = []
        for key, val in st.session_state.s2_data.items():
            row = val.copy()
            row['ç‡ƒæ–™é¡åˆ¥'] = val.get('name', key)
            row['æ’æ”¾é‡(tCO2e)'] = row['usage'] * row['factor']
            df2_data.append(row)
        df2 = pd.DataFrame(df2_data)
        df2 = df2[['ç‡ƒæ–™é¡åˆ¥', 'usage', 'unit', 'factor', 'æ’æ”¾é‡(tCO2e)']]  # Reorder
        df2.rename(columns={'usage': 'ä½¿ç”¨é‡', 'unit': 'å–®ä½', 'factor': 'æ’æ”¾ä¿‚æ•¸'}, inplace=True)
        df2.to_excel(writer, sheet_name='ç§»å‹•æº', index=False)

        # Sheet 3: æ±™æ°´
        if st.session_state.s3_septic_system == 'å¦ (ä½¿ç”¨åŒ–ç³æ± )':
            df3 = pd.DataFrame.from_dict(st.session_state.s3_data, orient='index')
            df3['æ’æ”¾é‡(tCO2e)'] = df3['usage'] * df3['factor'] * 28  # GWP for CH4
            df3.index.name = 'äººå“¡é¡åˆ¥'
            df3.reset_index(inplace=True)
            df3.rename(columns={'usage': 'äººæ•¸', 'factor': 'æ’æ”¾ä¿‚æ•¸(CH4)'}, inplace=True)
            df3.to_excel(writer, sheet_name='æ±™æ°´', index=False)

        # Sheet 4: æ»…ç«å™¨
        df4 = pd.DataFrame.from_dict(st.session_state.s4_data, orient='index')
        df4['æ’æ”¾é‡(tCO2e)'] = 0  # Initialize column
        df4.loc[df4['gwp'].notna(), 'æ’æ”¾é‡(tCO2e)'] = (df4['usage'] * df4['gwp']) / 1000
        df4.loc[df4['factor'].notna(), 'æ’æ”¾é‡(tCO2e)'] = df4['usage'] * df4['factor']
        df4.index.name = 'é¡åˆ¥'
        df4.reset_index(inplace=True)
        df4.rename(columns={'usage': 'æ¯å¹´å¡«å……/ä½¿ç”¨é‡(å…¬æ–¤/å¹´)', 'gwp': 'GWPä¿‚æ•¸', 'factor': 'æ’æ”¾ä¿‚æ•¸'}, inplace=True)
        df4.to_excel(writer, sheet_name='æ»…ç«å™¨', index=False)

        # Sheet 5: å†·åª’
        df5 = pd.DataFrame.from_dict(st.session_state.s5_data, orient='index')
        df5['æ’æ”¾é‡(tCO2e)'] = (df5['usage'] * df5['gwp']) / 1000
        df5.index.name = 'å†·åª’ç¨®é¡'
        df5.reset_index(inplace=True)
        df5.rename(columns={'usage': 'æ¯å¹´å¡«å……é‡(å…¬æ–¤/å¹´)', 'gwp': 'GWPä¿‚æ•¸'}, inplace=True)
        df5.to_excel(writer, sheet_name='å†·åª’', index=False)

        # Sheet 6: å“¡å·¥é€šå‹¤
        df6 = pd.DataFrame.from_dict(st.session_state.s6_data, orient='index')
        df6['æ’æ”¾é‡(tCO2e)'] = (df6['distance'] * df6['factor']) / 1000
        df6.index.name = 'äº¤é€šå·¥å…·'
        df6.reset_index(inplace=True)
        df6.rename(columns={'distance': 'ç¸½é€šå‹¤è·é›¢(å…¬é‡Œ/å¹´)', 'factor': 'æ’æ”¾ä¿‚æ•¸(KgCO2e/pkm)'}, inplace=True)
        df6.to_excel(writer, sheet_name='å“¡å·¥é€šå‹¤', index=False)

        # Sheet 7: å¤–è³¼é›»åŠ›
        df7_elec = pd.DataFrame(st.session_state.s7_electricity.items(), columns=['æœˆä»½', 'ç”¨é›»é‡(åº¦)'])
        df7_elec['æ’æ”¾é‡(tCO2e)'] = (df7_elec['ç”¨é›»é‡(åº¦)'] * 0.474) / 1000
        df7_elec.to_excel(writer, sheet_name='å¤–è³¼é›»åŠ›', index=False)

        # Sheet 8: å¤–è³¼æ°´åŠ›
        water_factor = st.session_state.water_factors[st.session_state.s7_water_source]
        df7_water = pd.DataFrame(st.session_state.s7_water.items(), columns=['æœˆä»½', 'ç”¨æ°´é‡(åº¦)'])
        df7_water['æ’æ”¾é‡(tCO2e)'] = (df7_water['ç”¨æ°´é‡(åº¦)'] * water_factor) / 1000

        # First, create the sheet by writing the DataFrame.
        df7_water.to_excel(writer, sheet_name='å¤–è³¼æ°´åŠ›', index=False)

        # Now that the sheet exists, get the worksheet object and write metadata.
        worksheet = writer.sheets['å¤–è³¼æ°´åŠ›']
        worksheet.write_string('E1', f'ä¾›æ°´å–®ä½: {st.session_state.s7_water_source}')
        worksheet.write_string('E2', f'æ’æ”¾ä¿‚æ•¸: {water_factor}')

    processed_data = output.getvalue()
    return processed_data


# =============================================================================
# Calculation Functions
# =============================================================================
def calculate_totals():
    """Calculate all emission totals and store them in session_state."""
    totals = {}
    gwp_ch4 = 28

    # Step 1
    totals['s1'] = sum(v['usage'] * v['factor'] for k, v in st.session_state.s1_data.items())

    # Step 2
    totals['s2'] = sum(v.get('usage', 0) * v.get('factor', 0) for k, v in st.session_state.s2_data.items())

    # Step 3
    is_septic_used = st.session_state.s3_septic_system == 'å¦ (ä½¿ç”¨åŒ–ç³æ± )'
    totals['s3'] = sum(
        v['usage'] * v['factor'] * gwp_ch4 for k, v in st.session_state.s3_data.items()) if is_septic_used else 0

    # Step 4
    s4_total = 0
    for k, v in st.session_state.s4_data.items():
        if v.get('gwp') is not None:
            s4_total += (v['usage'] * v['gwp']) / 1000
        elif v.get('factor') is not None:
            s4_total += v['usage'] * v['factor']
    totals['s4'] = s4_total

    # Step 5
    totals['s5'] = sum((v['usage'] * v['gwp']) / 1000 for k, v in st.session_state.s5_data.items())

    # Step 6
    totals['s6'] = sum((v['distance'] * v['factor']) / 1000 for k, v in st.session_state.s6_data.items())

    # Step 7
    total_electricity_usage = sum(st.session_state.s7_electricity.values())
    totals['s7_electricity'] = (total_electricity_usage * 0.474) / 1000

    total_water_usage = sum(st.session_state.s7_water.values())
    water_factor = st.session_state.water_factors[st.session_state.s7_water_source]
    totals['s7_water'] = (total_water_usage * water_factor) / 1000

    st.session_state.totals = totals

    # Scope Totals
    scope1 = totals['s1'] + totals['s2'] + totals['s3'] + totals['s4'] + totals['s5']
    scope2 = totals['s7_electricity']
    scope3 = totals['s6'] + totals['s7_water']
    st.session_state.scope_totals = {
        'Scope 1': scope1,
        'Scope 2': scope2,
        'Scope 3': scope3,
        'Grand Total': scope1 + scope2 + scope3
    }

    st.session_state.emission_breakdown = {
        'å›ºå®šæº': totals.get('s1', 0),
        'ç§»å‹•æº': totals.get('s2', 0),
        'æ±™æ°´': totals.get('s3', 0),
        'æ»…ç«å™¨': totals.get('s4', 0),
        'å†·åª’': totals.get('s5', 0),
        'å“¡å·¥é€šå‹¤': totals.get('s6', 0),
        'å¤–è³¼é›»åŠ›': totals.get('s7_electricity', 0),
        'å¤–è³¼æ°´åŠ›': totals.get('s7_water', 0),
    }


# =============================================================================
# UI Components
# =============================================================================
def main_app():
    """Renders the main application after login."""
    with st.sidebar:
        st.write(f"æ­¡è¿, {st.session_state.username}!")
        if st.button("ç™»å‡º"):
            for key in list(st.session_state.keys()):
                del st.session_state[key]
            st.rerun()

    if st.session_state.get("show_dashboard", False):
        create_dashboard()
    else:
        create_input_form()


def create_dashboard():
    """Renders the main dashboard view."""
    st.title(f"{st.session_state.inventory_year} å¹´åº¦æº«å®¤æ°£é«”ç›¤æŸ¥å„€è¡¨æ¿")
    if st.button("â¬…ï¸ è¿”å›ç·¨è¼¯è³‡æ–™"):
        st.session_state.show_dashboard = False
        st.rerun()

    scope = st.session_state.scope_totals

    # KPI Cards
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("ç¸½ç¢³æ’æ”¾é‡ (tCO2e)", f"{scope['Grand Total']:.2f}")
    col2.metric("ç¯„ç–‡ä¸€ Scope 1", f"{scope['Scope 1']:.2f}")
    col3.metric("ç¯„ç–‡äºŒ Scope 2", f"{scope['Scope 2']:.2f}")
    col4.metric("ç¯„ç–‡ä¸‰ Scope 3", f"{scope['Scope 3']:.2f}")

    st.divider()

    # Charts
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("å„é¡åˆ¥æ’æ”¾ä½”æ¯”")
        emissions = st.session_state.emission_breakdown
        # Filter out zero-value emissions for a cleaner chart
        filtered_emissions = {k: v for k, v in emissions.items() if v > 0}

        if filtered_emissions:
            fig = go.Figure(data=[go.Pie(
                labels=list(filtered_emissions.keys()),
                values=list(filtered_emissions.values()),
                hole=.4,
                textinfo='label+percent',
                insidetextorientation='radial'
            )])
            fig.update_layout(showlegend=False, height=400, margin=dict(l=20, r=20, t=20, b=20))
            st.plotly_chart(fig, use_container_width=True)
        else:
            st.write("ç›®å‰æ²’æœ‰å¯é¡¯ç¤ºçš„æ’æ”¾æ•¸æ“šã€‚")

    with col2:
        st.subheader("å„ç¯„ç–‡æ’æ”¾æ¯”è¼ƒ (tCO2e)")
        scope_df = pd.DataFrame({
            'ç¯„ç–‡': ['Scope 1', 'Scope 2', 'Scope 3'],
            'æ’æ”¾é‡': [scope['Scope 1'], scope['Scope 2'], scope['Scope 3']]
        })
        fig = go.Figure(go.Bar(
            x=scope_df['æ’æ”¾é‡'],
            y=scope_df['ç¯„ç–‡'],
            orientation='h',
            text=scope_df['æ’æ”¾é‡'].apply(lambda x: f'{x:.2f}'),
            textposition='auto',
            marker_color=['#10B981', '#F59E0B', '#8B5CF6']
        ))
        fig.update_layout(height=400, margin=dict(l=20, r=20, t=20, b=20))
        st.plotly_chart(fig, use_container_width=True)


def create_input_form():
    """Renders the multi-tab data input form."""
    st.title("æº«å®¤æ°£é«”ç›¤æŸ¥è³‡æ–™è¼¸å…¥")

    # --- FIX START: More robust year selection state management ---
    # Year Selector
    years_options = list(range(datetime.now().year + 25, 2019, -1))

    # Determine the index for the selectbox based on session state
    try:
        # Find the index of the year currently stored in session state
        index = years_options.index(st.session_state.inventory_year)
    except (KeyError, ValueError):
        # If the key doesn't exist or the year is invalid, default to the current year
        try:
            index = years_options.index(datetime.now().year)
        except ValueError:
            # As a final fallback, use the first item in the list
            index = 0

    # Create the selectbox and explicitly update session state with its value
    # This avoids issues with state being lost on reruns
    selected_year = st.selectbox(
        "ç›¤æŸ¥å¹´åº¦:",
        years_options,
        index=index
    )
    st.session_state.inventory_year = selected_year
    # --- FIX END ---

    st.info("è«‹å¡«å¯«ä»¥ä¸‹å„é¡åˆ¥çš„æ´»å‹•æ•¸æ“šï¼Œç³»çµ±å°‡è‡ªå‹•è¨ˆç®—æ’æ”¾é‡ã€‚")
    st.divider()

    # --- TABS FOR NAVIGATION ---
    tab1, tab2, tab3, tab4, tab5, tab6, tab7 = st.tabs([
        "1. å›ºå®šæº", "2. ç§»å‹•æº", "3. æ±™æ°´", "4. æ»…ç«å™¨",
        "5. å†·åª’", "6. å“¡å·¥é€šå‹¤", "7. é›»åŠ›/æ°´åŠ›"
    ])

    # --- Tab 1: Stationary Sources ---
    with tab1:
        cols = st.columns([2, 2, 1])
        cols[0].markdown("**ç‡ƒæ–™é¡åˆ¥**")
        cols[1].markdown("**ä½¿ç”¨é‡**")
        cols[2].markdown("**æ’æ”¾é‡è¨ˆç®— (tCO2e)**")

        data = st.session_state.s1_data
        total = 0
        for item, values in data.items():
            cols = st.columns([2, 2, 1])
            cols[0].write(f"{item} ({values['unit']})")
            values['usage'] = cols[1].number_input(" ", key=f"s1_{item}", value=values['usage'],
                                                   label_visibility="collapsed")
            emission = values['usage'] * values['factor']
            cols[2].text_input(" ", f"{emission:.4f}", key=f"s1_{item}_out", disabled=True,
                               label_visibility="collapsed")
            total += emission
        st.metric("å›ºå®šæºç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total:.4f}")

    # --- Tab 2: Mobile Sources ---
    with tab2:
        cols = st.columns([2, 2, 1])
        cols[0].markdown("**ç‡ƒæ–™é¡åˆ¥**")
        cols[1].markdown("**ä½¿ç”¨é‡**")
        cols[2].markdown("**æ’æ”¾é‡è¨ˆç®— (tCO2e)**")

        data = st.session_state.s2_data
        total = 0
        for item, values in data.items():
            cols = st.columns([2, 2, 1])
            name = values.get('name', item)
            cols[0].write(f"{name} ({values['unit']})")
            values['usage'] = cols[1].number_input(" ", key=f"s2_{item}", value=values['usage'],
                                                   label_visibility="collapsed")
            emission = values['usage'] * values['factor']
            cols[2].text_input(" ", f"{emission:.4f}", key=f"s2_{item}_out", disabled=True,
                               label_visibility="collapsed")
            total += emission
        st.metric("ç§»å‹•æºç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total:.4f}")

    # --- Tab 3: Wastewater ---
    with tab3:
        st.selectbox("å­¸æ ¡æ±™æ°´æ˜¯å¦æœ‰ç´å…¥æ±™æ°´ä¸‹æ°´é“ç³»çµ±ï¼Ÿ", ['å¦ (ä½¿ç”¨åŒ–ç³æ± )', 'æ˜¯ (ç„¡åŒ–ç³æ± é€¸æ•£)'],
                     key='s3_septic_system')
        total = 0
        if st.session_state.s3_septic_system == 'å¦ (ä½¿ç”¨åŒ–ç³æ± )':
            cols = st.columns([2, 2, 1])
            cols[0].markdown("**äººå“¡é¡åˆ¥**")
            cols[1].markdown("**äººæ•¸**")
            cols[2].markdown("**æ’æ”¾é‡è¨ˆç®— (tCO2e)**")

            data = st.session_state.s3_data
            for item, values in data.items():
                cols = st.columns([2, 2, 1])
                cols[0].write(f"{item}")
                values['usage'] = cols[1].number_input(" ", key=f"s3_{item}", value=values['usage'],
                                                       label_visibility="collapsed")
                emission = values['usage'] * values['factor'] * 28  # GWP for CH4
                cols[2].text_input(" ", f"{emission:.4f}", key=f"s3_{item}_out", disabled=True,
                                   label_visibility="collapsed")
                total += emission
        st.metric("æ±™æ°´æ’æ”¾ç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total:.4f}")

    # --- Tab 4: Fire Extinguishers ---
    with tab4:
        cols = st.columns([2, 2, 1])
        cols[0].markdown("**é¡åˆ¥**")
        cols[1].markdown("**æ¯å¹´å¡«å……/ä½¿ç”¨é‡ (å…¬æ–¤/å¹´)**")
        cols[2].markdown("**æ’æ”¾é‡è¨ˆç®— (tCO2e)**")

        data = st.session_state.s4_data
        total = 0
        for item, values in data.items():
            cols = st.columns([2, 2, 1])
            cols[0].write(f"{item}")
            values['usage'] = cols[1].number_input(" ", key=f"s4_{item}", value=values['usage'],
                                                   label_visibility="collapsed")
            emission = 0
            if values.get('gwp') is not None:
                emission = (values['usage'] * values['gwp']) / 1000
            elif values.get('factor') is not None:
                emission = values['usage'] * values['factor']
            cols[2].text_input(" ", f"{emission:.4f}", key=f"s4_{item}_out", disabled=True,
                               label_visibility="collapsed")
            total += emission
        st.metric("æ»…ç«å™¨ä½¿ç”¨ç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total:.4f}")

    # --- Tab 5: Refrigerants ---
    with tab5:
        cols = st.columns([2, 2, 1, 1])
        cols[0].markdown("**å†·åª’ç¨®é¡**")
        cols[1].markdown("**æ¯å¹´å¡«å……é‡ (å…¬æ–¤/å¹´)**")
        cols[2].markdown("**GWPä¿‚æ•¸**")
        cols[3].markdown("**æ’æ”¾é‡ (tCO2e)**")

        data = st.session_state.s5_data
        total = 0
        for item, values in data.items():
            cols = st.columns([2, 2, 1, 1])
            cols[0].write(f"{item}")
            values['usage'] = cols[1].number_input(" ", key=f"s5_{item}", value=values['usage'], step=0.1,
                                                   format="%.1f", label_visibility="collapsed")
            cols[2].text_input(" ", value=values['gwp'], key=f"s5_gwp_{item}", disabled=True,
                               label_visibility="collapsed")
            emission = (values['usage'] * values['gwp']) / 1000
            cols[3].text_input(" ", f"{emission:.4f}", key=f"s5_{item}_out", disabled=True,
                               label_visibility="collapsed")
            total += emission
        st.metric("å¡«å……å†·åª’ç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total:.4f}")

    # --- Tab 6: Commuting ---
    with tab6:
        cols = st.columns([2, 2, 1, 1])
        cols[0].markdown("**äº¤é€šå·¥å…·**")
        cols[1].markdown("**ç¸½é€šå‹¤è·é›¢ (å…¬é‡Œ/å¹´)**")
        cols[2].markdown("**æ’æ”¾ä¿‚æ•¸ (KgCO2e/pkm)**")
        cols[3].markdown("**æ’æ”¾é‡ (tCO2e)**")

        data = st.session_state.s6_data
        total = 0
        for item, values in data.items():
            cols = st.columns([2, 2, 1, 1])
            cols[0].write(f"{item}")
            values['distance'] = cols[1].number_input(" ", key=f"s6_{item}", value=values['distance'],
                                                      label_visibility="collapsed")
            cols[2].text_input(" ", value=values['factor'], key=f"s6_factor_{item}", disabled=True,
                               label_visibility="collapsed")
            emission = (values['distance'] * values['factor']) / 1000
            cols[3].text_input(" ", f"{emission:.4f}", key=f"s6_{item}_out", disabled=True,
                               label_visibility="collapsed")
            total += emission
        st.metric("å“¡å·¥é€šå‹¤ç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total:.4f}")

    # --- Tab 7: Utilities ---
    with tab7:
        st.subheader("7a. å¤–è³¼é›»åŠ› (åº¦)")
        data_elec = st.session_state.s7_electricity
        cols = st.columns(4)
        for i, month in enumerate(data_elec.keys()):
            data_elec[month] = cols[i % 4].number_input(month, key=f"s7_elec_{month}", value=data_elec[month])
        total_usage_elec = sum(data_elec.values())
        total_emission_elec = (total_usage_elec * 0.474) / 1000
        st.metric("ç¸½ç”¨é›»åº¦æ•¸", f"{total_usage_elec:,}")
        st.metric("å¤–è³¼é›»åŠ›ç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total_emission_elec:.4f}")
        st.divider()
        st.subheader("7b. å¤–è³¼æ°´åŠ› (åº¦)")
        st.selectbox("è«‹é¸æ“‡ä¾›æ°´å–®ä½", options=list(st.session_state.water_factors.keys()), key='s7_water_source')
        data_water = st.session_state.s7_water
        cols = st.columns(4)
        for i, month in enumerate(data_water.keys()):
            data_water[month] = cols[i % 4].number_input(month, key=f"s7_water_{month}", value=data_water[month])
        total_usage_water = sum(data_water.values())
        water_factor = st.session_state.water_factors[st.session_state.s7_water_source]
        total_emission_water = (total_usage_water * water_factor) / 1000
        st.metric("ç¸½ç”¨æ°´åº¦æ•¸", f"{total_usage_water:,}")
        st.metric("å¤–è³¼æ°´åŠ›ç¢³æ’æ”¾ç•¶é‡ (tCO2e)", f"{total_emission_water:.4f}")

    st.divider()

    # --- Action Buttons ---
    col1, col2 = st.columns([1, 3])

    with col1:
        # NEW: Download Button
        excel_data = to_excel()
        st.download_button(
            label="ğŸ“¥ ä¸‹è¼‰Excelè³‡æ–™",
            data=excel_data,
            file_name=f"GHGç›¤æŸ¥è³‡æ–™_{st.session_state.inventory_year}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            use_container_width=True
        )

    with col2:
        if st.button("âœ… è¨ˆç®—ä¸¦æŸ¥çœ‹å„€è¡¨æ¿", use_container_width=True, type="primary"):
            calculate_totals()
            st.session_state.show_dashboard = True
            st.rerun()


# =============================================================================
# Main App Logic
# =============================================================================
if "logged_in" not in st.session_state:
    st.session_state.logged_in = False

if st.session_state.logged_in:
    initialize_state()
    main_app()
else:
    login_page()
